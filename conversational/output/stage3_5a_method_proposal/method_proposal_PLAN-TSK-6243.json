{
  "_meta": {
    "timestamp": "2025-12-10T03:27:16.118788",
    "checksum": "755d7d06d0559bb6",
    "version": "1.0",
    "stage": "stage3_5a",
    "type": "method_proposal"
  },
  "data": {
    "plan_id": "PLAN-TSK-6243",
    "methods_proposed": [
      {
        "method_id": "M1",
        "name": "Naive Forecast",
        "category": "baseline",
        "description": "Predicts using last observed value",
        "implementation_code": "def predict_naive(train_df, test_df, target_col, date_col, **params):\n    import pandas as pd\n    if len(train_df) == 0:\n        return pd.DataFrame({'predicted': [0]*len(test_df)}).set_index(test_df.index)\n    last_value = train_df[target_col].iloc[-1]\n    return pd.DataFrame({'predicted': [last_value]*len(test_df)}).set_index(test_df.index)",
        "required_libraries": [
          "pandas"
        ],
        "hyperparameters": {},
        "expected_strengths": [
          "Simple baseline for forecasting"
        ],
        "expected_weaknesses": [
          "Does not account for trends/seasonality"
        ]
      },
      {
        "method_id": "M2",
        "name": "ARIMA",
        "category": "statistical/traditional",
        "description": "Autoregressive Integrated Moving Average model",
        "implementation_code": "def predict_arima(train_df, test_df, target_col, date_col, **params):\n    import pandas as pd\n    from statsmodels.tsa.arima.model import ARIMA\n    train_series = train_df[target_col].asfreq('Y')\n    model = ARIMA(train_series, order=(1,1,0))\n    results = model.fit()\n    forecast = results.forecast(steps=len(test_df))\n    return pd.DataFrame({'predicted': forecast.values}, index=test_df.index)",
        "required_libraries": [
          "pandas",
          "statsmodels"
        ],
        "hyperparameters": {
          "order": "(1,1,0)"
        },
        "expected_strengths": [
          "Captures trends in time series"
        ],
        "expected_weaknesses": [
          "May miss complex seasonality"
        ]
      },
      {
        "method_id": "M3",
        "name": "XGBoost with Lags",
        "category": "ml",
        "description": "Tree-based model with lag features",
        "implementation_code": "def predict_xgboost(train_df, test_df, target_col, date_col, **params):\n    import pandas as pd\n    from xgboost import XGBRegressor\n    train_series = train_df[target_col].values\n    X_train = [train_series[i-3:i] for i in range(3, len(train_series))]\n    y_train = train_series[3:]\n    model = XGBRegressor(n_estimators=100, learning_rate=0.1)\n    model.fit(X_train, y_train)\n    X_test = [train_series[-3:]]\n    forecast = model.predict(X_test)\n    return pd.DataFrame({'predicted': forecast}, index=test_df.index)",
        "required_libraries": [
          "pandas",
          "xgboost"
        ],
        "hyperparameters": {
          "n_estimators": 100,
          "learning_rate": 0.1
        },
        "expected_strengths": [
          "Captures non-linear patterns"
        ],
        "expected_weaknesses": [
          "Requires careful feature engineering"
        ]
      }
    ],
    "data_split_strategy": {
      "strategy_type": "temporal_column",
      "date_column": "period",
      "target_column": "2024 - 25-Quantity",
      "train_period": "2018-2022",
      "validation_period": "2023",
      "test_period": "2024-2027"
    },
    "evaluation_metrics": [
      "mae",
      "rmse",
      "mape",
      "r2"
    ],
    "date_column": "period",
    "target_column": "2024 - 25-Quantity"
  }
}