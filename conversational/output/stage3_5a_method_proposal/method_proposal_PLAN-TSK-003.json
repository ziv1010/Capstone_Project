{
  "_meta": {
    "timestamp": "2025-12-07T12:51:53.529663",
    "checksum": "64a7bfb9cb27f449",
    "version": "1.0",
    "stage": "stage3_5a",
    "type": "method_proposal"
  },
  "data": {
    "plan_id": "PLAN-TSK-003",
    "methods_proposed": [
      {
        "method_id": "M1",
        "name": "Threshold Baseline",
        "category": "baseline",
        "description": "Predicts based on 3-year average exceeding training data mean",
        "implementation_code": "def predict_threshold_baseline(train_df, test_df, target_col, **params):\n    threshold = train_df[target_col].mean()\n    predictions = (test_df['avg_yield_3yr'] > threshold).astype(int)\n    return pd.DataFrame({'predicted': predictions}, index=test_df.index)",
        "required_libraries": [
          "pandas"
        ],
        "hyperparameters": {},
        "expected_strengths": [
          "Simple implementation",
          "Quick baseline for comparison"
        ],
        "expected_weaknesses": [
          "Ignores temporal patterns",
          "No feature interactions"
        ]
      },
      {
        "method_id": "M2",
        "name": "Logistic Regression",
        "category": "statistical/traditional",
        "description": "Uses 3-year average and yield trend with logistic regression",
        "implementation_code": "def predict_logistic_regression(train_df, test_df, target_col, **params):\n    from sklearn.linear_model import LogisticRegression\n    from sklearn.preprocessing import StandardScaler\n    X_train = train_df[['avg_yield_3yr', 'yield_trend']]\n    y_train = (train_df[target_col] > train_df[target_col].mean()).astype(int)\n    X_test = test_df[['avg_yield_3yr', 'yield_trend']]\n    scaler = StandardScaler()\n    X_train_scaled = scaler.fit_transform(X_train)\n    X_test_scaled = scaler.transform(X_test)\n    model = LogisticRegression(**params)\n    model.fit(X_train_scaled, y_train)\n    predictions = model.predict(X_test_scaled)\n    return pd.DataFrame({'predicted': predictions}, index=test_df.index)",
        "required_libraries": [
          "pandas",
          "sklearn.linear_model",
          "sklearn.preprocessing"
        ],
        "hyperparameters": {
          "C": 1.0
        },
        "expected_strengths": [
          "Interpretable coefficients",
          "Handles linear relationships"
        ],
        "expected_weaknesses": [
          "Assumes linearity",
          "May miss complex patterns"
        ]
      },
      {
        "method_id": "M3",
        "name": "Random Forest",
        "category": "ml",
        "description": "Ensemble of decision trees using engineered features",
        "implementation_code": "def predict_random_forest(train_df, test_df, target_col, **params):\n    from sklearn.ensemble import RandomForestClassifier\n    X_train = train_df[['avg_yield_3yr', 'yield_trend']]\n    y_train = (train_df[target_col] > train_df[target_col].mean()).astype(int)\n    X_test = test_df[['avg_yield_3yr', 'yield_trend']]\n    model = RandomForestClassifier(**params)\n    model.fit(X_train, y_train)\n    predictions = model.predict(X_test)\n    return pd.DataFrame({'predicted': predictions}, index=test_df.index)",
        "required_libraries": [
          "pandas",
          "sklearn.ensemble"
        ],
        "hyperparameters": {
          "n_estimators": 100
        },
        "expected_strengths": [
          "Handles non-linear relationships",
          "Robust to overfitting"
        ],
        "expected_weaknesses": [
          "Less interpretable",
          "Computationally intensive"
        ]
      }
    ],
    "data_split_strategy": {
      "strategy_type": "temporal_column",
      "date_column": null,
      "target_column": "Yield-2024-25",
      "train_period": "Years 2020-2023",
      "validation_period": "Year 2023-24",
      "test_period": "Year 2024-25"
    },
    "date_column": null,
    "target_column": "Yield-2024-25"
  }
}